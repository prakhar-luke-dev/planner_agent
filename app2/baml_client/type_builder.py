###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Add","Divide","Executor","Multiply","Planner","Resume","Subtract",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def Add(self) -> "AddAst":
        return AddAst(self)

    @property
    def Divide(self) -> "DivideAst":
        return DivideAst(self)

    @property
    def Executor(self) -> "ExecutorAst":
        return ExecutorAst(self)

    @property
    def Multiply(self) -> "MultiplyAst":
        return MultiplyAst(self)

    @property
    def Planner(self) -> "PlannerAst":
        return PlannerAst(self)

    @property
    def Resume(self) -> "ResumeAst":
        return ResumeAst(self)

    @property
    def Subtract(self) -> "SubtractAst":
        return SubtractAst(self)





class AddAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Add")
        self._properties: typing.Set[str] = set([ "num1_to_add",  "num2_to_add", ])
        self._props = AddProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AddProperties":
        return self._props


class AddViewer(AddAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AddProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def num1_to_add(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num1_to_add"))

    @property
    def num2_to_add(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num2_to_add"))

    

class DivideAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Divide")
        self._properties: typing.Set[str] = set([ "num1_to_divide",  "num2_to_divide", ])
        self._props = DivideProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DivideProperties":
        return self._props


class DivideViewer(DivideAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DivideProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def num1_to_divide(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num1_to_divide"))

    @property
    def num2_to_divide(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num2_to_divide"))

    

class ExecutorAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Executor")
        self._properties: typing.Set[str] = set([ "plan",  "ans_part2", ])
        self._props = ExecutorProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExecutorProperties":
        return self._props


class ExecutorViewer(ExecutorAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExecutorProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def plan(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("plan"))

    @property
    def ans_part2(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("ans_part2"))

    

class MultiplyAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Multiply")
        self._properties: typing.Set[str] = set([ "num1_to_multiply",  "num2_to_multiply", ])
        self._props = MultiplyProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MultiplyProperties":
        return self._props


class MultiplyViewer(MultiplyAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class MultiplyProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def num1_to_multiply(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num1_to_multiply"))

    @property
    def num2_to_multiply(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num2_to_multiply"))

    

class PlannerAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Planner")
        self._properties: typing.Set[str] = set([ "steps",  "ans_part1", ])
        self._props = PlannerProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PlannerProperties":
        return self._props


class PlannerViewer(PlannerAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PlannerProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def steps(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("steps"))

    @property
    def ans_part1(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("ans_part1"))

    

class ResumeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Resume")
        self._properties: typing.Set[str] = set([ "name",  "email",  "experience",  "skills", ])
        self._props = ResumeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResumeProperties":
        return self._props


class ResumeViewer(ResumeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResumeProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def email(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("email"))

    @property
    def experience(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("experience"))

    @property
    def skills(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("skills"))

    

class SubtractAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Subtract")
        self._properties: typing.Set[str] = set([ "num1_to_subtract",  "num2_to_subtract", ])
        self._props = SubtractProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SubtractProperties":
        return self._props


class SubtractViewer(SubtractAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SubtractProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def num1_to_subtract(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num1_to_subtract"))

    @property
    def num2_to_subtract(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("num2_to_subtract"))

    




__all__ = ["TypeBuilder"]